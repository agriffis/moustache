{"name":"Moustache","tagline":"a micro web framework/internal DSL to wire Ring handlers and middlewares","body":"h1. Moustache\r\n\r\n<pre>\r\n  (app [\"hi\"] {:get \"Hello World!\"})\r\n</pre>\r\n\r\nMoustache is a micro web framework/internal DSL to wire Ring handlers and middlewares.\r\n\r\nh2. How micro is it?\r\n\r\nWell, there's only one macro you need to know: @app@. \r\n\r\nEvery other public var is public only because @app@ needs it in its expansion.\r\n\r\nh2. Syntax\r\n\r\nSee \"syntax.html\":http://moustache.cgrand.net/syntax.html\r\n\r\nh2. Walkthrough\r\n\r\nhttp://gist.github.com/109955\r\n\r\nh2. The @app@ macro\r\n\r\nA @(app ...)@ form returns a Ring application (handler).\r\n\r\nThere's currently four usages of @app@:\r\n* to wrap a Ring handler,\r\n* to define routes,\r\n* to dispatch on HTTP methods\r\n* and to render plain text.\r\n\r\nh3. Wrapping an existing Ring handler\r\n\r\n<pre>\r\n  (app my-handler) ; identity, returns my-handler\r\n</pre> \r\n\r\nYou can simply wrap a handler into middlewares:\r\n<pre>\r\n  (app\r\n    middleware1\r\n    (middleware2 arg)\r\n    my-handler)\r\n  ; equivalent to (-> my-handler (middleware2 arg) middleware1)\r\n  ; ie (middleware1 (middleware2 my-handler arg))\r\n</pre>\r\n\r\nNote that *every usage of @app@ supports middleware-wrapping*.\r\n\r\nh3. Routes\r\n\r\nh4. Basics\r\n\r\nWith Moustache you don't write routes as encoded uri (eg @\"/Thank%20you%20Mario/But%20our%20princess%20is%20in%20another%20castle\"@), you write vectors of decoded segments (eg @[\"Thank you Mario\" \"But our princess is in another castle\"]@).\r\n\r\n<pre>\r\n  (app [\"foo\"] my-handler) ; will route requests to \"/foo\" to my-handler\r\n  (app [\"foo\" \"\"] my-handler) ; will route requests to \"/foo/\" to my-handler\r\n  (app [\"foo\" \"bar\"] my-handler) ; will route requests to \"/foo/bar\" to my-handler\r\n  (app [\"foo\" &] my-handler) ; will route requests to \"/foo\", \"/foo/\", \"/foo/bar\" and \"/foo/bar/baz/\" to my-handler (and will chop \"/foo\" off from the uri)\r\n  (app [\"foo\" name] my-handler) ; will route requests to \"/foo/\", \"/foo/bar\" to my-handler and bind @name@ (a local) to the matched segment (eg \"\" or \"bar\")\r\n  (app [\"foo\" x & xs] my-handler) ; \"/foo/bar/baz/bloom\" will bind x to bar and xs to [\"baz\" \"bloom\"]\r\n</pre>\r\n\r\nYou can catch all URIs with the route <code>[&]</code>. If you don't provide a handler for <code>[&]</code> and there's no handler for a request Moustache sends a 404 (not found) response.\r\n\r\nh4. Route validation/destructuring\r\n\r\n<pre>\r\n  (defn integer [s]\r\n   \"returns nil if s does not represent an integer\r\n    (try \r\n      (Integer/parseInt s)\r\n      (catch Exception e)))\r\n\r\n  (app [\"order\" [id integer]] my-handler) ; for \"/order/134\" @id@ will be bind to 134 (not \"134\"), this route will not match \"/order/abc\".\r\n  \r\n  (app [\"agenda\" [[_ year month day] #\"(\\d{4})-(\\d{2})-(\\d{2})\"]] \r\n    {:get [month \"-\" day \"-\" year \" agenda\"]})\r\n</pre>\r\n\r\nh4. Fall through\r\n\r\nThe routes are tried in order until one route matches the request uri *and* the associated handler does not return nil.\r\n\r\nThat's why:\r\n\r\n<pre>\r\n  (app \r\n    [\"foo\" &] (app [\"bar\"] handler1)\r\n    [\"foo\" \"baz\"] handler2)\r\n</pre>\r\n\r\nreturns a 404 for /foo/baz: the nested @app@ form returns a 404 for /baz and this 404 bubbles up.\r\n\r\nYou can prevent such behavior by writing:\r\n\r\n<pre>\r\n  (app \r\n    [\"foo\" &] (app \r\n                [\"bar\"] handler1\r\n                [&] pass)\r\n    [\"foo\" \"baz\"] handler2)\r\n</pre>\r\n\r\n \r\n\r\nh3. Method dispatch\r\n\r\n<pre>\r\n  (app\r\n    :get handler-for-get\r\n    :post handler-for-post)\r\n</pre>\r\n\r\nYou can add a catch-all using the :any keyword.\r\n\r\nIf you don't specify a handler for :any, Moustache sends a 405 response (method not allowed).\r\n\r\nh3. Shorthands\r\n\r\nWhen the right-hand form of a route or of a method dispatch is a @(app ...)@ form, you can write the form as a vector: <code>(app [\"foo\" &] (app [\"bar\"] handler))</code> can be shortened to <code>(app [\"foo\" &] [[\"bar\"] handler])</code>.\r\n\r\nBesides when the right-hand form is a method dispatch without middlewares you can write the form as a map:  <code>(app [\"foo\"] (app :get handler))</code> can be shortened to <code>(app [\"foo\"] {:get handler})</code>.\r\n\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","google":""}